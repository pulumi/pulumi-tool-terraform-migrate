package tfmig

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	tfjson "github.com/hashicorp/terraform-json"
	"github.com/pulumi/pulumi/sdk/v3/go/auto"
	"github.com/pulumi/pulumi/sdk/v3/go/common/resource"
)

// MigrationFile represents the top-level structure of migration.json
type MigrationFile struct {
	Migration Migration `json:"migration"`
}

// Migration contains the configuration for migrating from Terraform to Pulumi
type Migration struct {
	TFSources     string  `json:"tf-sources"`
	PulumiSources string  `json:"pulumi-sources"`
	Stacks        []Stack `json:"stacks"`
}

// Stack represents a mapping between a Terraform state and a Pulumi stack
type Stack struct {
	// File path to a Terraform state file. It can be in JSON format (ends with .json), or in raw binary format
	// (ends with .tfstate).
	TFState     string     `json:"tf-state"`
	PulumiStack string     `json:"pulumi-stack"`
	Resources   []Resource `json:"resources"`
	// File path to import-stub.json generated by pulumi preview --import-file
	ImportStubFile string `json:"import-stub-file,omitempty"`
	// File path to resolved import.json with actual import IDs filled in
	ImportResolvedFile string `json:"import-resolved-file,omitempty"`
}

// Resource represents a mapping between a Terraform resource and a Pulumi resource
type Resource struct {
	TFAddr  string `json:"tf-addr,omitempty"`
	URN     string `json:"urn,omitempty"`
	Migrate string `json:"migrate,omitempty"` // e.g., "skip"
}

// LoadMigration reads and parses a migration.json file
func LoadMigration(path string) (*MigrationFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var mf MigrationFile
	if err := json.Unmarshal(data, &mf); err != nil {
		return nil, err
	}

	return &mf, nil
}

// Save writes the migration file to disk
func (mf *MigrationFile) Save(path string) error {
	data, err := json.MarshalIndent(mf, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

// InitMigrationOptions contains options for initializing a migration
type InitMigrationOptions struct {
	MigrationFile string
	TFSources     string
	PulumiSources string
}

// InitMigration discovers Terraform workspaces, extracts states for each, and writes migration.json
func InitMigration(opts InitMigrationOptions) error {
	// Convert paths to absolute paths
	tfSourcesAbs, err := filepath.Abs(opts.TFSources)
	if err != nil {
		return fmt.Errorf("failed to resolve tf-sources path: %w", err)
	}

	pulumiSourcesAbs, err := filepath.Abs(opts.PulumiSources)
	if err != nil {
		return fmt.Errorf("failed to resolve pulumi-sources path: %w", err)
	}

	migrationFileAbs, err := filepath.Abs(opts.MigrationFile)
	if err != nil {
		return fmt.Errorf("failed to resolve migration file path: %w", err)
	}

	// Verify Terraform directory exists
	if _, err := os.Stat(tfSourcesAbs); err != nil {
		return fmt.Errorf("terraform sources directory does not exist: %w", err)
	}

	// Read Pulumi project name from Pulumi.yaml
	projectName, err := ReadPulumiProjectName(pulumiSourcesAbs)
	if err != nil {
		return fmt.Errorf("failed to read Pulumi project name: %w", err)
	}

	// Discover Terraform workspaces
	workspaces, err := discoverTerraformWorkspaces(tfSourcesAbs)
	if err != nil {
		return fmt.Errorf("failed to discover workspaces: %w", err)
	}

	if len(workspaces) == 0 {
		return fmt.Errorf("no terraform workspaces found in %s", tfSourcesAbs)
	}

	// Create stacks for each workspace
	var stacks []Stack
	for _, workspace := range workspaces {
		// Extract state for this workspace
		stateFile, err := extractTerraformState(tfSourcesAbs, workspace)
		if err != nil {
			return fmt.Errorf("failed to extract state for workspace %s: %w", workspace, err)
		}

		// Read the state to collect resource addresses
		state, err := LoadTerraformState(stateFile)
		if err != nil {
			return fmt.Errorf("failed to load state for workspace %s: %w", workspace, err)
		}

		// Collect all resource addresses
		resources, err := initResourceMapping(state, projectName, workspace)
		if err != nil {
			return fmt.Errorf("failed to collect resources for workspace %s: %w", workspace, err)
		}

		stack := Stack{
			TFState:     stateFile,
			PulumiStack: workspace,
			Resources:   resources,
		}
		stacks = append(stacks, stack)
	}

	// Create migration file
	migrationFile := &MigrationFile{
		Migration: Migration{
			TFSources:     tfSourcesAbs,
			PulumiSources: pulumiSourcesAbs,
			Stacks:        stacks,
		},
	}

	// Save to disk
	if err := migrationFile.Save(migrationFileAbs); err != nil {
		return fmt.Errorf("failed to save migration file: %w", err)
	}

	return nil
}

// discoverTerraformWorkspaces discovers all Terraform workspaces in a directory
func discoverTerraformWorkspaces(tfDir string) ([]string, error) {
	// Run terraform workspace list
	cmd := exec.Command("terraform", "workspace", "list")
	cmd.Dir = tfDir
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to list workspaces (make sure terraform is initialized): %w", err)
	}

	// Parse output - each line is a workspace, current one has a * prefix
	var workspaces []string
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		// Remove the * prefix if present
		workspace := strings.TrimPrefix(line, "* ")
		workspaces = append(workspaces, workspace)
	}

	return workspaces, nil
}

// extractTerraformState extracts the state for a given workspace to a JSON file in system temp directory
func extractTerraformState(tfDir, workspace string) (string, error) {
	// Create output file path in system temp directory
	stateFile := filepath.Join(os.TempDir(), fmt.Sprintf("tfstate-%s-%s.json", filepath.Base(tfDir), workspace))

	// Select the workspace
	selectCmd := exec.Command("terraform", "workspace", "select", workspace)
	selectCmd.Dir = tfDir
	if err := selectCmd.Run(); err != nil {
		return "", fmt.Errorf("failed to select workspace %s: %w", workspace, err)
	}

	// Extract state using terraform show -json
	showCmd := exec.Command("terraform", "show", "-json")
	showCmd.Dir = tfDir
	output, err := showCmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to extract state for workspace %s: %w", workspace, err)
	}

	// Write to file in temp directory
	if err := os.WriteFile(stateFile, output, 0644); err != nil {
		return "", fmt.Errorf("failed to write state file: %w", err)
	}

	return stateFile, nil
}

// ReadPulumiProjectName reads the project name from Pulumi.yaml using the automation API
func ReadPulumiProjectName(pulumiDir string) (string, error) {
	ctx := context.Background()

	// Create a LocalWorkspace pointing to the Pulumi project directory
	ws, err := auto.NewLocalWorkspace(ctx, auto.WorkDir(pulumiDir))
	if err != nil {
		return "", fmt.Errorf("failed to create Pulumi workspace: %w", err)
	}

	// Get the project settings
	projectSettings, err := ws.ProjectSettings(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to read project settings: %w", err)
	}

	return projectSettings.Name.String(), nil
}

func initResourceMapping(state *tfjson.State, projectName, stackName string) ([]Resource, error) {
	var resources []Resource

	// Create a TypeMapper to convert TF resource types to Pulumi tokens
	typeMapper := NewTypeMapper()
	ctx := context.Background()

	// Track type:name combinations to ensure uniqueness
	typeNameSeen := make(map[string]int) // key: "type:name", value: count of times seen

	err := VisitResources(state, func(res *tfjson.StateResource) error {
		// Not interested in data sources.
		if res.Mode == tfjson.DataResourceMode {
			return nil
		}

		// Try to map the TF resource type to a Pulumi token
		resourceType, err := typeMapper.PulumiResourceTypeForState(ctx, *res)
		if err != nil {
			// If mapping fails, mark resource as skip
			resources = append(resources, Resource{
				TFAddr:  res.Address,
				Migrate: "skip",
			})
			return nil
		}

		if resourceType != "" {
			var resourceName string = res.Name

			// Ensure unique (type, name) combinations by appending _1, _2, etc. to duplicates
			typeNameKey := string(resourceType) + ":" + resourceName
			if count, exists := typeNameSeen[typeNameKey]; exists {
				// Disambiguate by appending _1, _2, _3, etc.
				resourceName = fmt.Sprintf("%s_%d", resourceName, count)
				typeNameSeen[typeNameKey] = count + 1
			} else {
				// First time seeing this combination
				typeNameSeen[typeNameKey] = 1
			}

			var parent resource.URN = "" // assume no parent
			urn := resource.CreateURN(resourceName, string(resourceType), parent, projectName, stackName)
			resources = append(resources, Resource{
				TFAddr: res.Address,
				URN:    string(urn),
			})
		} else {
			resources = append(resources, Resource{
				TFAddr:  res.Address,
				Migrate: "skip",
			})
		}
		return nil

	})

	if err != nil {
		return nil, err
	}

	return resources, nil
}
